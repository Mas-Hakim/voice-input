<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>ASR Chrome 141 Mobile Simple</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {
    margin: 0;
    background: #0f1115;
    color: #e6e6e6;
    font-family: system-ui, sans-serif;
}
.container {
    max-width: 900px;
    margin: 20px auto;
    padding: 20px;
}
.controls {
    display: flex;
    gap: 8px;
    margin-bottom: 10px;
}
button {
    background: #1f2430;
    color: #fff;
    border: 1px solid #2f3545;
    border-radius: 6px;
    padding: 8px 14px;
}
textarea, pre {
    width: 100%;
    min-height: 180px;
    background: #151821;
    color: #f1f1f1;
    border: 1px solid #2a2f3a;
    border-radius: 8px;
    padding: 12px;
    font-size: 14px;
}
pre {
    font-size: 12px;
    white-space: pre-wrap;
    overflow: auto;
    color: #9aa0aa;
}
.hidden { display: none; }
.status {
    margin-top: 8px;
    font-size: 12px;
    color: #9aa0aa;
}
</style>
</head>
<body>

<div class="container">
    <div class="controls">
        <button id="tab-asr">ASR</button>
        <button id="tab-logs">Logs</button>
        <button id="start">Start</button>
        <button id="stop">Stop</button>
        <button id="clear">Clear</button>
    </div>

    <textarea id="asr"></textarea>
    <pre id="logs" class="hidden"></pre>
    <div class="status" id="status">Idle</div>
</div>

<script>
/* ================= DOM ================= */
const asr = document.getElementById("asr");
const logs = document.getElementById("logs");
const status = document.getElementById("status");

document.getElementById("tab-asr").onclick  = () => { asr.classList.remove("hidden"); logs.classList.add("hidden"); };
document.getElementById("tab-logs").onclick = () => { asr.classList.add("hidden"); logs.classList.remove("hidden"); };

/* ================= LOG ================= */
function log(label, data) {
    logs.textContent += `[${label}]\n${JSON.stringify(data, null, 2)}\n\n`;
    logs.scrollTop = logs.scrollHeight;
}

log("ENV", {
    ua: navigator.userAgent,
    isChromeMobile141:
        /Chrome\/141\./.test(navigator.userAgent) &&
        /Mobile/.test(navigator.userAgent) &&
        /Android/.test(navigator.userAgent)
});

/* ================= TYPEWRITER ================= */
/*
  Мы теперь поддерживаем:
  - interimStart: позиция в textarea, с которой показывается текущий interim-фрагмент
  - interimLength: длина этого interim-фрагмента
  - isAnimating: чтобы не смешивать параллельные анимации
  - pendingText: если приходит новый текст во время анимации — он ставится в очередь
*/
let interimStart = null;
let interimLength = 0;
let isAnimating = false;
let pendingText = null;

function typewriterOverwrite(textarea, text, opts = {}) {
    const ERASE_DELAY = 6;
    const TYPE_DELAY  = 14;

    // Если уже анимируем — положим в pending (заменяем предыдущий pending — хотим последний текст)
    if (isAnimating) {
        pendingText = { text, opts };
        return;
    }

    isAnimating = true;
    textarea.disabled = true;

    // Базовая позиция — либо текущий interimStart (если есть), либо текущая позиция каретки
    const basePos = (interimLength > 0 && Number.isInteger(interimStart)) ? interimStart : Math.max(0, textarea.selectionStart || 0);

    // Сколько символов нужно стереть перед набором — текущее interimLength (если оно относится к той позиции)
    let currentEraseLen = (interimLength > 0 && interimStart === basePos) ? interimLength : 0;
    let typeIndex = 0;

    function finish() {
        if (opts.final) {
            // Для final результата передвинем каретку за вставленный фрагмент и сбросим interim
            const caretPos = Math.min(basePos + text.length, textarea.value.length);
            textarea.selectionStart = textarea.selectionEnd = caretPos;
            interimLength = 0;
            interimStart = null;
        } else {
            // Для interim — сохраним позицию и длину
            interimStart = basePos;
            interimLength = text.length;
            // Оставим каретку там, где пользователь сидел (не двигаем)
        }

        isAnimating = false;
        textarea.disabled = false;

        // Если что-то отложено — запустим следующий фрагмент чуть позже
        if (pendingText !== null) {
            const next = pendingText;
            pendingText = null;
            setTimeout(() => typewriterOverwrite(textarea, next.text, next.opts), 30);
        }
    }

    function eraseStep() {
        if (currentEraseLen <= 0) return typeStep();

        // Удаляем последний символ из промежуточного фрагмента (в позиции basePos)
        const before = textarea.value.slice(0, basePos);
        const after  = textarea.value.slice(basePos + currentEraseLen);
        const keep   = textarea.value.slice(basePos, basePos + currentEraseLen - 1); // не обязательно, можно не использовать
        textarea.value = before + textarea.value.slice(basePos, basePos + currentEraseLen - 1) + after;

        currentEraseLen--;
        setTimeout(eraseStep, ERASE_DELAY);
    }

    function typeStep() {
        if (typeIndex >= text.length) {
            finish();
            return;
        }
        // Вставляем символ в позицию basePos + typeIndex
        const before = textarea.value.slice(0, basePos + typeIndex);
        const after  = textarea.value.slice(basePos + typeIndex);
        textarea.value = before + text[typeIndex++] + after;
        setTimeout(typeStep, TYPE_DELAY);
    }

    eraseStep();
}

/* ================= WEB SPEECH ================= */
const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
if (!SR) alert("SpeechRecognition not supported");

const rec = new SR();
rec.lang = "ru-RU";
rec.interimResults = true;
rec.continuous = true;
rec.maxAlternatives = 1;

rec.onstart = () => {
    status.textContent = "Listening…";
    // При старте можно оставить interimStart/length как есть — если они были, мы продолжим перезапись там.
    // Если нужно всегда начинать от текущей каретки, можно сбросить interimLength = 0;
};
rec.onend   = () => status.textContent = "Stopped";
rec.onerror = e => log("ERROR", e);

rec.onresult = (event) => {

    const idx = event.results.length - 1;
    const alt = event.results[idx][0];
    if (!alt) return;

    const text = alt.transcript?.trim();
    const confidence = alt.confidence ?? 0;
    if (!text) return;

    log("RESULT", { index: idx, text, confidence });

    if (confidence === 0) {
        // INTERIM — всегда показываем в одном месте (в позиции interimStart или каретки)
        typewriterOverwrite(asr, text, { final: false });
    } else {
        // FINAL — допечатываем и ПОСЛЕ этого двигаем каретку за вставленный текст
        typewriterOverwrite(asr, text + " ", { final: true });
        // Заметим: теперь finish() внутри typewriterOverwrite установит caret именно за вставленным фрагментом
    }
};

/* ================= CONTROLS ================= */
document.getElementById("start").onclick = () => rec.start();
document.getElementById("stop").onclick  = () => rec.stop();
document.getElementById("clear").onclick = () => {
    asr.value = "";
    logs.textContent = "";
    interimLength = 0;
    interimStart = null;
    pendingText = null;
};
</script>
</body>
</html>
